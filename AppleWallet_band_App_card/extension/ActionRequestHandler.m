//
//  WNonUIExtHandler.m
//  IssuerApp
//
//  Created by Generated by Mark on 2026
//

#import "ActionRequestHandler.h"
#import <os/log.h>

@implementation ActionRequestHandler {
    PKPassLibrary *_passLibrary;
    WatchConnectivitySession *_watchSession;
    os_log_t _log;
}

- (instancetype)init {
    self = [super init];
    if (self) {
        _passLibrary = [[PKPassLibrary alloc] init];
        _watchSession = [[WatchConnectivitySession alloc] init];
        _log = os_log_create("com.example.IssuerApp", "ActionRequestHandler");
    }
    return self;
}

#pragma mark - PKIssuerProvisioningExtensionHandler

// 设置扩展的状态，指示支付通行证是否可添加以及添加是否需要身份验证
- (void)statusWithCompletion:(void (^)(PKIssuerProvisioningExtensionStatus * _Nonnull))completion {
    PKIssuerProvisioningExtensionStatus *status = [[PKIssuerProvisioningExtensionStatus alloc] init];
    
    NSArray<PKPass *> *paymentPassLibrary = @[];
    NSMutableSet<NSString *> *passIdentifiers = [NSMutableSet set];
    NSMutableSet<NSString *> *remotePassIdentifiers = [NSMutableSet set];
    NSInteger availablePassesForIphone = 0;
    NSInteger availableRemotePassesForAppleWatch = 0;
    
    // 获取已存在于Apple Pay中的支付通行证的标识符
    paymentPassLibrary = [_passLibrary passesOfType:PKPassTypeSecureElement];
    
    for (PKPass *pass in paymentPassLibrary) {
        NSString *identifier = pass.secureElementPass.primaryAccountIdentifier;
        if (identifier) {
            if (pass.isRemotePass && [pass.deviceName localizedCaseInsensitiveContainsString:@"Apple Watch"]) {
                [remotePassIdentifiers addObject:identifier];
            } else if (!pass.isRemotePass) {
                [passIdentifiers addObject:identifier];
            }
        }
    }
    
    // 从用户的默认数据库中获取应用内用户所有已发行卡的缓存凭据数据
    NSData *cachedCredentialsData = [AppGroupShared.appGroupSharedDefaults dataForKey:@"PaymentPassCredentials"];
    
    if (cachedCredentialsData) {
        NSError *error = nil;
        NSDictionary *decoded = [NSKeyedUnarchiver unarchivedObjectOfClasses:[NSSet setWithObjects:[NSDictionary class], [ProvisioningCredential class], [NSString class], nil] fromData:cachedCredentialsData error:&error];
        
        if (!error && [decoded isKindOfClass:[NSDictionary class]]) {
            for (NSString *identifier in decoded.allKeys) {
                // 修复：添加完整的条件判断 - 检查卡片是否尚未添加到当前设备
                if (![passIdentifiers containsObject:identifier]) {
                    availablePassesForIphone++;
                }
                
                // 修复：添加完整的条件判断 - 检查卡片是否尚未添加到Apple Watch
                if (_watchSession.isPaired && ![remotePassIdentifiers containsObject:identifier]) {
                    availableRemotePassesForAppleWatch++;
                }
            }
        } else {
            os_log_error(_log, "Error occurred while decoding cachedCredentialsData: %{public}@", error.localizedDescription);
        }
    } else {
        os_log_info(_log, "Unable to find credentials of passes available to add to Apple Pay.");
    }
    
    // 设置扩展的状态
    status.passEntriesAvailable = availablePassesForIphone > 0;
    status.remotePassEntriesAvailable = _watchSession.isPaired && availableRemotePassesForAppleWatch > 0;
    
    // 修复：添加默认值，避免key不存在时返回NO
    if ([AppGroupShared.appGroupSharedDefaults objectForKey:@"ShouldRequireAuthenticationForAppleWallet"] != nil) {
        status.requiresAuthentication = [AppGroupShared.appGroupSharedDefaults boolForKey:@"ShouldRequireAuthenticationForAppleWallet"];
    } else {
        // 如果没有设置，默认需要认证
        status.requiresAuthentication = YES;
    }
    // 调用完成处理程序
    completion(status);
}

// 返回表示可添加到iPhone的支付通行证的通行证条目列表
- (void)passEntriesWithCompletion:(void (^)(NSArray<PKIssuerProvisioningExtensionPassEntry *> * _Nonnull))completion {
    NSMutableArray<PKIssuerProvisioningExtensionPassEntry *> *passEntries = [NSMutableArray array];
    NSArray<PKPass *> *paymentPassLibrary = @[];
    NSMutableSet<NSString *> *passLibraryIdentifiers = [NSMutableSet set];
    
    // 获取已存在于Apple Pay中的支付通行证的标识符
    paymentPassLibrary = [_passLibrary passesOfType:PKPassTypeSecureElement];
    
    for (PKPass *pass in paymentPassLibrary) {
        if (!pass.isRemotePass) {
            NSString *identifier = pass.secureElementPass.primaryAccountIdentifier;
            if (identifier) {
                [passLibraryIdentifiers addObject:identifier];
            }
        }
    }
    
    // 从用户的默认数据库中获取应用内用户所有已发行卡的缓存凭据数据
    NSData *cachedCredentialsData = [AppGroupShared.appGroupSharedDefaults dataForKey:@"PaymentPassCredentials"];
    
    if (cachedCredentialsData) {
        NSError *error = nil;
        NSDictionary *decoded = [NSKeyedUnarchiver unarchivedObjectOfClasses:[NSSet setWithObjects:[NSDictionary class], [ProvisioningCredential class], [NSString class], nil] fromData:cachedCredentialsData error:&error];
        
        if (!error && [decoded isKindOfClass:[NSDictionary class]]) {
            // 仅为可添加到Apple Pay的卡创建支付通行证条目，并将条目添加到passEntries列表
            for (NSString *identifier in decoded.allKeys) {
                // 修复：添加完整的条件判断 - 仅包含未添加到当前设备的卡片
                if (![passLibraryIdentifiers containsObject:identifier]) {
                    ProvisioningCredential *credential = decoded[identifier];
                    if ([credential isKindOfClass:[ProvisioningCredential class]]) {
                        PKIssuerProvisioningExtensionPassEntry *entry = [self getPaymentPassEntryWithProvisioningCredential:credential];
                        if (entry) {
                            [passEntries addObject:entry];
                        }
                    }
                }
            }
        } else {
            os_log_error(_log, "Error occurred while decoding cachedCredentialsData: %{public}@", error.localizedDescription);
        }
    } else {
        os_log_info(_log, "Unable to find credentials of passes available to add to Apple Pay on iPhone.");
    }
    
    // 调用完成处理程序
    completion([passEntries copy]);
}

// 返回表示可添加到Apple Watch的支付通行证的通行证条目列表
- (void)remotePassEntriesWithCompletion:(void (^)(NSArray<PKIssuerProvisioningExtensionPassEntry *> * _Nonnull))completion {
    NSMutableArray<PKIssuerProvisioningExtensionPassEntry *> *passEntries = [NSMutableArray array];
    NSArray<PKPass *> *paymentPassLibrary = @[];
    NSMutableSet<NSString *> *passLibraryIdentifiers = [NSMutableSet set];
    
    // 获取已存在于Apple Pay中的支付通行证的标识符（仅Apple Watch）
    paymentPassLibrary = [_passLibrary passesOfType:PKPassTypeSecureElement];
    
    for (PKPass *pass in paymentPassLibrary) {
        if (pass.isRemotePass && [pass.deviceName localizedCaseInsensitiveContainsString:@"Apple Watch"]) {
            NSString *identifier = pass.secureElementPass.primaryAccountIdentifier;
            if (identifier) {
                [passLibraryIdentifiers addObject:identifier];
            }
        }
    }
    
    // 从用户的默认数据库中获取应用内用户所有已发行卡的缓存凭据数据
    NSData *cachedCredentialsData = [AppGroupShared.appGroupSharedDefaults dataForKey:@"PaymentPassCredentials"];
    
    if (cachedCredentialsData) {
        NSError *error = nil;
        NSDictionary *decoded = [NSKeyedUnarchiver unarchivedObjectOfClasses:[NSSet setWithObjects:[NSDictionary class], [ProvisioningCredential class], [NSString class], nil] fromData:cachedCredentialsData error:&error];
        
        if (!error && [decoded isKindOfClass:[NSDictionary class]]) {
            // 仅为可添加到Apple Pay的卡创建支付通行证条目，并将条目添加到passEntries列表
            for (NSString *identifier in decoded.allKeys) {
                // 修复：添加完整的条件判断 - 仅包含未添加到Apple Watch的卡片，且需要已配对
                if (_watchSession.isPaired && ![passLibraryIdentifiers containsObject:identifier]) {
                    ProvisioningCredential *credential = decoded[identifier];
                    if ([credential isKindOfClass:[ProvisioningCredential class]]) {
                        PKIssuerProvisioningExtensionPassEntry *entry = [self getPaymentPassEntryWithProvisioningCredential:credential];
                        if (entry) {
                            [passEntries addObject:entry];
                        }
                    }
                }
            }
        } else {
            os_log_error(_log, "Error occurred while decoding cachedCredentialsData: %{public}@", error.localizedDescription);
        }
    } else {
        os_log_info(_log, "Unable to find credentials of passes available to add to Apple Pay on Apple Watch.");
    }
    
    // 调用完成处理程序
    completion([passEntries copy]);
}

// 根据用户选择的支付通行证生成添加到Apple Pay的请求
- (void)generateAddPaymentPassRequestForPassEntryWithIdentifier:(NSString *)identifier
                                                  configuration:(PKAddPaymentPassRequestConfiguration *)configuration
                                              certificateChain:(NSArray<NSData *> *)certificates
                                                          nonce:(NSData *)nonce
                                                 nonceSignature:(NSData *)nonceSignature
                                              completionHandler:(void (^)(PKAddPaymentPassRequest * _Nullable))completion {
    
    PKAddPaymentPassRequest *request = [[PKAddPaymentPassRequest alloc] init];
    
    // 生成加密的通行证数据
    EncryptedPassDataResponse *passData = [PassResource requestPaymentPassDataWithConfiguration:configuration
                                                                              certificateChain:certificates
                                                                                          nonce:nonce
                                                                                 nonceSignature:nonceSignature];
    
    // 将加密的通行证数据插入PKAddPaymentPassRequest
    request.activationData = passData.activationData;
    request.encryptedPassData = passData.encryptedPassData;
    request.ephemeralPublicKey = passData.ephemeralPublicKey;
    
    // 调用完成处理程序
    completion(request);
}

#pragma mark - Private Methods

// 返回支付通行证条目
- (PKIssuerProvisioningExtensionPaymentPassEntry *)getPaymentPassEntryWithProvisioningCredential:(ProvisioningCredential *)provisioningCredential {
    NSString *identifier = provisioningCredential.primaryAccountIdentifier;
    NSString *label = provisioningCredential.label;
    
    // 为添加支付通行证创建请求配置，以包含在支付通行证条目中
    PKAddPaymentPassRequestConfiguration *requestConfig = [[PKAddPaymentPassRequestConfiguration alloc] initWithEncryptionScheme:PKEncryptionSchemeECC_V2];
    requestConfig.primaryAccountIdentifier = identifier;
    requestConfig.paymentNetwork = PKPaymentNetworkMasterCard;
    requestConfig.cardholderName = provisioningCredential.cardholderName;
    requestConfig.localizedDescription = provisioningCredential.localizedDescription;
    requestConfig.primaryAccountSuffix = provisioningCredential.primaryAccountSuffix;
    requestConfig.style = PKAddPaymentPassStylePayment;
    
    // 附加额外的卡详细信息
    PKLabeledValue *expirationDetail = [[PKLabeledValue alloc] initWithLabel:@"expiration" value:provisioningCredential.expiration];
    requestConfig.cardDetails = @[expirationDetail];
    
    // 实例化并返回支付通行证条目
    UIImage *uiImage = [UIImage imageNamed:provisioningCredential.assetName];
    if (!uiImage) {
        uiImage = [UIImage imageNamed:@"generic"];
    }
    
    CGImageRef art = [self getEntryArtWithImage:uiImage];
    PKIssuerProvisioningExtensionPaymentPassEntry *entry = [[PKIssuerProvisioningExtensionPaymentPassEntry alloc] initWithIdentifier:identifier title:label art:art addRequestConfiguration:requestConfig];
    CGImageRelease(art); // 释放CGImage
    
    return entry;
}

// 将UIImage转换为CGImage
- (CGImageRef)getEntryArtWithImage:(UIImage *)image {
    CIImage *ciImage = [[CIImage alloc] initWithImage:image];
    CIContext *ciContext = [CIContext contextWithOptions:nil];
    CGImageRef cgImage = [ciContext createCGImage:ciImage fromRect:ciImage.extent];
    return cgImage;
}

@end
